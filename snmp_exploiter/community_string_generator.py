from itertools import chain
from typing import Callable, Iterable, List

from common.credentials import Identity, Password, Secret, Username
from infection_monkey.exploit.tools import identity_type_filter, secret_type_filter
from infection_monkey.propagation_credentials_repository import IPropagationCredentialsRepository


class CommunityStringGenerator:
    """
    Generates community strings from the credentials in the repository
    """

    def __init__(
        self,
        propagation_credentials_repository: IPropagationCredentialsRepository,
    ):
        self._propagation_credentials_repository = propagation_credentials_repository

    def generate_community_strings(self) -> Iterable[str]:
        """
        Yields community strings from the credentials in the repository

        :return: An iterable of potential community strings
        """
        for credential in self._generate_credentials(
            identity_type_filter=identity_type_filter([Username]),
            secret_type_filter=secret_type_filter([Password]),
        ):
            yield self._credential_to_community_string(credential)

    def _generate_credentials(
        self,
        identity_type_filter: Callable[[Identity], bool] = lambda identity: True,
        secret_type_filter: Callable[[Identity], bool] = lambda secret: True,
    ) -> Iterable[Identity | Secret]:
        propagation_credentials = self._propagation_credentials_repository.get_credentials()
        identities: List[Identity] = []
        secrets: List[Secret] = []

        for credentials in propagation_credentials:
            if credentials.identity:
                identities.append(credentials.identity)
            if credentials.secret:
                secrets.append(credentials.secret)

        for credential in chain(
            filter(identity_type_filter, dict.fromkeys(identities)),
            filter(secret_type_filter, dict.fromkeys(secrets)),
        ):
            yield credential

    def _credential_to_community_string(self, credential: Identity | Secret) -> str:
        if isinstance(credential, Username):
            return credential.username
        elif isinstance(credential, Password):
            return credential.password.get_secret_value()
        else:
            raise TypeError(f"Unexpected credential type: {type(credential)}")
